# 单例模式

## 前言

单例模式大家都很熟悉，基本上做开发的人都知道有这个模式，用途也很明确。但是深挖一下，就会发现好多东西。个人认为，单例模式是创建唯一对象并为其提供全局访问的方法。

单例模式有四种：懒汉式单例、饿汗式单例、静态内部类单例以及枚举式单例。这四种单例模式是一步步过渡的，最开始是懒汉式和饿汉式，两者一个是类使用时初始化、一个是类加载时直接初始化实例。然后就是静态内部类单例，利用静态内部类的特性使得外部类使用时不会加载内部类，调用到内部类的时候才会加载内部类，将懒汗式和饿汉式的优点结合。但是不论是懒汉式、饿汗式还是静态内部类都会被序列化后反序列化以及反射破坏单例，枚举式单例则是解决这一问题的答案。

## 各类型单例实现

### 懒汉式单例

懒加载，对象使用时再去创建，私有构造方法并提供一个返回实例对象的方法，方法中对对象双重非空判断并加锁以及volatile关键字修饰对象禁止指令重排保证其线程安全。

#### 实例

```java
/**
 * 懒汉式单例：私有构造方法，双重非空校验，创建对象时加锁，volatile关键字禁止指令重排保证创建对象这一步骤的线程安全
 *
 * @author linmeng
 * @version 1.0
 * @date 2022年3月28日 16:42
 */
public class LazySingleton implements Serializable {
    private static volatile LazySingleton lazySingleton;

    private LazySingleton() {
    }

    public static LazySingleton getInstance() {
        if (Objects.isNull(lazySingleton)) {
            synchronized (LazySingleton.class) {
                if (Objects.isNull(lazySingleton)) {
                    lazySingleton = new LazySingleton();
                }
            }
        }

        return lazySingleton;
    }
}

```

#### 优缺点

优点：类加载时不实例化对象，使用时才对对象进行实例化，减少内存消耗

缺点：使用了同步锁，对性能有一定影响，反射以及序列化后反序列化都能破坏单例

#### 原理

##### volatile关键字作用

jvm创建对象分为三个步骤

1. 为对象分配空间
2. 初始化对象
3. 将初始化的对象指向分配的空间

jvm在执行语句时，为了提高性能，有可能不按照代码顺序执行。这时候，代码执行顺序有可能变成1 3 2.这个时候一个线程走到3那一步，但是没有初始化对象，另一个线程判断非空，对象不为空，直接返回未初始化的对象进行使用，这就会造成空指针。

但是用了volatile关键字，禁止指令重排，就不会出现这种情况。

### 饿汉式单例

在程序加载时创建对象，调用时直接返回

#### 实例

```java
/**
 * 饿汉式单例：static关键字使得变量在类加载时就初始化，final关键字使得变量不可被修改
 * @author linmeng
 * @version 1.0
 * @date 2022年3月28日 16:55
 */
public class EagerSingleton implements Serializable {
    private static final EagerSingleton eagerSingleton = new EagerSingleton();

    private EagerSingleton(){}

    /**
     *
     * 直接返回
     * @author linmeng
     * @date 2021年11月9日 21:44
     * @return com.sword.www.designPattern.singleton.EagerSingleton
     */
    public static EagerSingleton getInstance(){

        return eagerSingleton;
    }
}
```

#### 优缺点

优点：代码逻辑简单易懂

缺点：占用内存，反射、序列化后反序列化都能破坏单例

### 静态内部类单例

私有构造方法，定义一个静态内部类，内部类中声明对象，再定义一个获取实例的方法获取内部类中的实例。

#### 实例

```java
/**
 * 静态内部类单例：外部类加载时不会加载内部类，只有在使用到内部类的时候虚拟机才会加载内部类
 * 保证了线程安全，单例的唯一性，延迟了类的实例化
 * https://blog.csdn.net/mnb65482/article/details/80458571
 * https://juejin.cn/post/6871497501732519949
 *
 * @author linmeng
 * @version 1.0
 * @date 2022年3月28日 17:00
 */
public class StaticNestSingleton implements Serializable {

    private StaticNestSingleton() {
    }

    private static class SingletonHolder {
        private static final StaticNestSingleton SINGLETON = new StaticNestSingleton();
    }

    /**
     * 直接返回
     *
     * @return com.sword.www.designPattern.singleton.EagerSingleton
     * @author linmeng
     * @date 2021年11月9日 21:44
     */
    public static StaticNestSingleton getInstance() {

        return SingletonHolder.SINGLETON;
    }
}
```

优点：利用虚拟机的机制保证了线程安全。类加载时不会加载内部类，使用时才会加载，相当于懒汉式和饿汉式的优点结合

缺点：会被序列化后反序列化破坏单例

### 枚举式单例

直接定义一个枚举类。

#### 实例

```java
/**
 * https://www.cnblogs.com/happy4java/p/11206105.html
 * https://blog.csdn.net/weixin_48358336/article/details/120499442
 *
 * @author linmeng
 * @date 2022年3月28日 17:09
 * @return
 */
public enum EnumSingleton {
    INSTANCE;

    public void doSomething() {
        System.out.println("do something");
    }
}
```

#### 优缺点

优点：代码简单，保证了在多线程下的安全性。利用虚拟机机制防止反射、序列化后反序列化

缺点：哪有什么缺点

## 单例破坏

使用一些特殊手段可以同时实例化多个单例对象，这样就破坏了单例模式。破坏单例的手段有这几种：

- 多线程：多线程下看获取到的单例对象是否为同一个，这个文中的单例代码均不受其破坏
- 反射：反射使用私有构造除枚举式单例可以不被破坏，其他单例均需要在代码层面处理
- 序列化后反序列化：将对象序列化成文件，再对其反序列化

#### 多线程破坏

使用CountDownLatch使得多个线程同时获取单例对象，通过检查对象地址判断是否创建了多个单例对象从而破坏单例

```java
public void concurrentDestroy() throws InterruptedException, ExecutionException {
        // 定长线程池
        ExecutorService executorService = Executors.newFixedThreadPool(5);
        // 使得多个线程同一时刻启动
        CountDownLatch countDownLatch = new CountDownLatch(5);
        // 1:饿汉式
        System.out.println("饿汉式地址打印");
        List<Future<EagerSingleton>> eagerSingletonFutureList = new ArrayList<>();
        for (int i = 0; i < 5; i++) {
            Future<EagerSingleton> future = executorService.submit(() -> {
                countDownLatch.countDown();
                return EagerSingleton.getInstance();
            });
            eagerSingletonFutureList.add(future);
        }
        countDownLatch.await();
        // 对象地址打印
        print(eagerSingletonFutureList);
        // 2:懒汉式
        System.out.println("懒汉式地址打印");
        List<Future<LazySingleton>> lazySingletonFutureList = new ArrayList<>();
        CountDownLatch countDownLatch1 = new CountDownLatch(5);
        for (int i = 0; i < 5; i++) {
            Future<LazySingleton> future = executorService.submit(() -> {
                countDownLatch1.countDown();
                return LazySingleton.getInstance();
            });
            lazySingletonFutureList.add(future);
        }
        countDownLatch1.await();
        // 对象地址打印
        print(lazySingletonFutureList);
        // 3:内部类
        System.out.println("内部类地址打印");
        List<Future<StaticNestSingleton>> staticNestSingletonFutureList = new ArrayList<>();
        CountDownLatch countDownLatch2 = new CountDownLatch(5);
        for (int i = 0; i < 5; i++) {
            Future<StaticNestSingleton> future = executorService.submit(() -> {
                countDownLatch2.countDown();
                return StaticNestSingleton.getInstance();
            });
            staticNestSingletonFutureList.add(future);
        }
        countDownLatch2.await();
        // 对象地址打印
        print(staticNestSingletonFutureList);
        // 4:枚举
        System.out.println("枚举相等判断");
        List<Future<EnumSingleton>> enumSingletonFutureList = new ArrayList<>();
        CountDownLatch countDownLatch3 = new CountDownLatch(5);
        for (int i = 0; i < 5; i++) {
            Future<EnumSingleton> future = executorService.submit(() -> {
                countDownLatch3.countDown();
                return EnumSingleton.INSTANCE;
            });
            enumSingletonFutureList.add(future);
        }
        countDownLatch3.await();
        // 对象地址判断
        System.out.println((enumSingletonFutureList.get(0).get()==enumSingletonFutureList.get(1).get())&&
                (enumSingletonFutureList.get(0).get()==enumSingletonFutureList.get(1).get()) &&
                (enumSingletonFutureList.get(1).get()==enumSingletonFutureList.get(2).get()) &&
                (enumSingletonFutureList.get(2).get()==enumSingletonFutureList.get(3).get()) &&
                (enumSingletonFutureList.get(3).get()==enumSingletonFutureList.get(4).get()));
    }
```

对象打印方法

```
 /**
     * 打印对象
     * @param list
     * @param <T>
     */
    <T> void print(List<Future<T>> list){
        list.forEach(s ->{
            try {
                System.out.println(s.get().toString());
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }
        });
    }
```



## 单例破坏问题解决