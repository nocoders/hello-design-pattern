# 原型模式

## 介绍

原型模式是指定类型，通过克隆创建大量的同类型对象的一种设计模式。原型模式的核心是原型类（Prototype），原型类实现了Cloneable接口并重写了Object类中的clone方法。

一般我们可以将原型类定义为一个接口，实现Cloneable接口，然后将需要大量克隆对象的类实现原型类，并重写克隆方法，这样该类new的对象就可以通过克隆方法克隆大量对象。相比直接new出来的对象，使用克隆方法性能更好。

## 细节说明

### Cloneable接口的作用

程序运行时，虚拟机会检查对象是否实现Cloneable接口，实现该接口的对象可以使用Object的clone（）方法，返回一个对象的拷贝。如果没有实现该接口，调用clone方法就会抛出CloneNotSupportedException异常。

那为什么所有的对象都可以调用clone方法呢？因为Java中所有对象都是继承的Object，clone方法在Object中已经实现。

如果你去java.lang包下面找到Cloneable接口，会发现这个接口是一个空接口。我们有理由怀疑这个接口在代码编译时是不起作用的，在虚拟机运行时发光发热。

## 原型模式类型

### 简单模式

简单模式包含如下角色：

1. Prototype:原型接口，实现了Cloneable接口
2. Concrete Prototype：具体原型，被复制的对象，实现了原型接口并重写了clone方法。
3. client：使用原型的客户，说白了就是调用者。

#### 代码示例

```
//原型接口
public interface Prototype extends Cloneable {

    Prototype clone();
}
//具体实现类
public class ConcretePrototype implements Prototype {
	// get set方法已省略
	private String type;
    public void show(){
        System.out.println("原型模式实现类");
    }
    @Override
    public Prototype clone() {
        Prototype prototype = null;
        try {
            prototype = (Prototype)super.clone();
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
        return prototype;
    }
    /**
     * 判断克隆方法是否调用构造创建对象
     */
    public ConcretePrototype() {
        System.out.println("构造方法被调用");
    }

    public static void main(String[] args) {
        ConcretePrototype concretePrototype = new ConcretePrototype();
        ConcretePrototype clone = (ConcretePrototype)concretePrototype.clone();
        clone.show();
    }
}
```

看完上面的代码后，Prototype原型类有一种累赘的感觉，如果没有这个类，会不会更好一点。

#### 代码优化

```
public class ConcretePrototype2 implements Cloneable{

    @Override
    public ConcretePrototype2 clone() {
        try {
            return (ConcretePrototype2) super.clone();
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
        return null;
    }
}
```

#### 使用场景

如果我们要使用简单模式的话，需要让对象实现Cloneable接口，然后重写clone方法。比较简单，适用于相同类型只有单独的一个对象需要克隆。

### 登记模式

登记模式跟简单模式相比多了一个原型管理器，使用原型管理器管理对象的克隆。对象既然要管理，那就肯定不是一个对象，使用Map管理多个对象。

```
public class PrototypeManager {
    /**
     * 用来记录原型的编号同原型实例的对象关系
     */
    private static Map<String, Prototype> PROTOTYPE_MAP = new HashMap<>();

    /**
     * 私有化构造方法，避免从外部创建实例
     */
    private PrototypeManager() {
    }

    /**
     * 向原型管理器里面添加或者修改原型实例
     *
     * @param prototypeId 原型编号
     * @param prototype   原型实例
     */
    public static void setProtoType(String prototypeId, Prototype prototype) {
        PROTOTYPE_MAP.put(prototypeId, prototype);
    }

    /**
     * 根据原型编号从原型管理器里面移除原型实例
     *
     * @param prototypeId 原型编号
     */
    public static void removePrototype(String prototypeId) {
        PROTOTYPE_MAP.remove(prototypeId);
    }

    /**
     * 根据原型编号获取原型实例
     *
     * @param prototypeId 原型编号
     * @return 原型实例对象
     * @throws Exception 如果根据原型编号无法获取对应实例，则提示异常“您希望获取的原型还没有注册或已被销毁”
     */
    public static Prototype getPrototype(String prototypeId) throws Exception {
        Prototype prototype = PROTOTYPE_MAP.get(prototypeId);

        if (prototype == null) {
            throw new Exception("您希望获取的原型还没有注册或已被销毁");
        }

        return prototype;
    }

}
//  测试方法
 @Test
 public void registerTest() throws Exception {
     PrototypeManager.setProtoType("1",new ConcretePrototype());
     PrototypeManager.setProtoType("2",new ConcretePrototype2());
     Prototype prototype = PrototypeManager.getPrototype("1").clone();
     Prototype prototype2 = PrototypeManager.getPrototype("2").clone();
     System.out.println(prototype);
     System.out.println(prototype2);
 }
```



## 克隆方式

### 浅克隆

### 深克隆

## 优缺点

## 参考链接

1. [一天一个设计模式(四) - 原型模式(Prototype)](https://juejin.cn/post/6844903638138093581)
2. [设计模式 - Prototype 原型模式](https://juejin.cn/post/6963416852647116807)
3. [原型模式（原型设计模式）详解](http://c.biancheng.net/view/1343.html)
4. [23种设计模式（5）：原型模式](https://blog.csdn.net/zhengzhb/article/details/7393528)